
obs_mat <- function(nobs = 1000, p, sd = 1) {
  obs_mat <- matrix(nrow = nobs, ncol = p)
  for (i in seq(p)) {
    obs_mat[, i] <- rnorm(nobs, sd = sd)
  }
  obs_mat
}

cali_Z <- function(gamma, W, e) {
  cali_Z <- W %*% gamma + e
  cali_Z
}

Z <- function(kappa, J = 3, cali_Z) {
  assert <- length(kappa) == J - 1
  if (!assert) {
    stop("kappa must be of length ", J - 1)
  }
  kappa_vec <- c(-Inf, kappa, Inf)
  Z <- findInterval(cali_Z, kappa_vec)
  Z
}

## potentially different equation for each j
y_j <- function(X_j, b_j, eta_j) {
  y_j <- X_j %*% b_j + eta_j
  y_j
}

errors <- function(Sigma, nobs = 1000) {
  assert <- Sigma[1, 1] == 1
  if (!assert) {
    stop("Sigma[1, 1] must be 1 but is ", Sigma[1, 1])
  }
  mu <- numeric(length = nrow(Sigma))
  errors <- mvtnorm::rmvnorm(n = nobs, mean = mu, sigma = Sigma)
  class(errors) <- c("errors", class(errors))
  errors
}

## hard-coded specification
sim_dat_1 <- function(sigma = NULL) {
  ## same vars are important in all models
  W <- X <- obs_mat(p = 2, sd = 0.5)  # otherwise perfect separation

  if (is.null(sigma)) {
    sigma <- matrix(c(
      1.0, 0.2, 0.3, 0.4,
      0.2, 1.1, 0.4, 0.5,
      0.3, 0.4, 1.2, 0.6,
      0.4, 0.5, 0.6, 1.3), ncol = 4)  # J = 3
  }
  err <- errors(sigma)

  e <- err[, 1]
  eta1 <- err[, 2]
  eta2 <- err[, 3]
  eta3 <- err[, 4]
  gamma <- c(1, 1.5)
  cali_z <- cali_Z(gamma, W, e)
  kappa <- c(-2, 1)
  z <- Z(kappa, J = 3, cali_z)

  b1 <- c(1, 1.1)
  b2 <- c(-1, 1.5)
  b3 <- c(1.6, -2)
  y1 <- y_j(X, b1, eta1)
  y2 <- y_j(X, b2, eta2)
  y3 <- y_j(X, b3, eta3)

  params <- list(
    gamma = gamma,
    kappa = kappa,
    beta1 = b1,
    beta2 = b2,
    beta3 = b3
  )

  data <- data.frame(
    Z = z,
    Y = ifelse(z == 1, y1, ifelse(z == 2, y2, y3)),
    X
  )

  out <- list(
    params = params,
    data = data,
    errors = err,
    sigma = sigma
  )

  out
}
