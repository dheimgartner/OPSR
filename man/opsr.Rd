% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/opsr.R
\name{opsr}
\alias{opsr}
\title{Fitting ordinal probit switching regression models}
\usage{
opsr(
  formula,
  data,
  subset,
  weights,
  na.action,
  start = NULL,
  method = "BFGS",
  iterlim = 1000,
  printLevel = 2,
  ...
)
}
\arguments{
\item{formula}{an object of class \verb{"Formula" "formula"}: A symbolic description
of the model to be fitted. The details of model specification are given under
'Details'.}

\item{data}{an optional data frame, list or environment (or object coercible by
\code{\link{as.data.frame}} to a data frame) containing the variables in the model. If
not found in \code{data}, the variables are taken from \code{environment(formula)},
typically the environment from which \code{opsr} is called.}

\item{subset}{an optional vector specifying a subset of observations to be used
in the fitting process. (See additional details about how this argument
interacts with data-dependent bases in the 'Details' section of the \code{\link{model.frame}}
documentation.).}

\item{weights}{an optional vector of weights to be used in the fitting process.
Should be \code{NULL} or a numeric vector. If non-NULL, then observation-specific
log-likelihood contributions are multiplied by their corresponding weight
before summing.}

\item{na.action}{a function which indicates what should happen when the data
contain \code{NA}s. The default is set by the \code{na.action} setting of \code{\link{options}},
and is \code{\link{na.fail}} if that is unset. The 'factory-fresh' default is \code{\link{na.omit}}.
Another possible value is \code{NULL}, no action. Value \code{\link{na.exclude}} can be useful.}

\item{start}{a named numeric vector with the starting values (passed to \code{\link{maxLik}}).
If no starting values are provided, reasonable values are auto-generated via
the 2-step procedure. The structure of \code{start} has to conform with \code{opsr}'s
expectations. An example is included in the error message if this should not
be the case.}

\item{method}{defaults to \code{"BFGS"} (see \code{\link{maxLik}}).}

\item{iterlim}{defaults to 1000 (see \code{\link{maxLik}}).}

\item{printLevel}{defaults to 2 (see \code{\link{maxLik}}).}

\item{...}{passed to \code{\link{maxLik}}.}
}
\value{
an object of class \verb{"opsr" "maxLik" "maxim"}.
}
\description{
High-level formula interface to the workhorse \code{\link{opsr.fit}}.
}
\details{
Models for \code{opsr} are specified symbolically. A typical model has the form
\code{ys | yo ~ terms_s | terms_o1 | terms_o2 | ...}.
\code{ys} is the ordered (numeric) response vector (starting from 1,
in integer-increasing fashion). For the \code{terms} specification the rules of
the regular formula interface apply. See also \link[stats:lm]{stats::lm} or the 'Examples'
section below.  The intercept in the \code{terms_s} (selection process) is excluded automatically
(no need to specify \code{-1}). If the user wants to specify the same process for
all continuous outcomes, two processes are enough (\code{ys | yo ~ terms_s | terms_o}).
Note that the model is poorly identifyable if \code{terms_s == terms_o} (same regressors
are used in selection and outcome processes).
}
\examples{
\dontrun{
sim_dat <- opsr_simulate()
dat <- sim_dat$data
formula <- ys | yo ~ xs1 + xs2 | xo1 + xo2 | xo1 + xo2 | xo1 + xo2
formula <- ys | yo ~ xs1 + xs2 | xo1 + xo2  # equivalent to above
system.time(
  fit_nm <- opsr(formula, dat, method = "NM")
)
system.time(
  fit_bfgs <- opsr(formula, dat, method = "BFGS")
)
summary(fit_nm)
summary(fit_bfgs)
class(fit_bfgs)

## ground truth
sim_dat$params
sim_dat$sigma
}
}
